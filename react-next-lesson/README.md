### README.md

# Навчальний проект на Next.js

Цей проект є навчальною платформою, побудованою з використанням фреймворку Next.js. Він демонструє основи компоненто-орієнтованого підходу та організації проекту за кращими практиками з використанням App Router.

## Встановлення

### 1. Створення нового проекту

Щоб створити новий проект на Next.js, скористайтеся командою:

```bash
npx create-next-app@latest my-next-app
```

При цьому ви можете вказати додаткові параметри, наприклад, чи потрібно додавати TypeScript, ESLint, Tailwind CSS та інші інструменти.

### 2. Перейдіть до папки проекту

```bash
cd my-next-app
```

### 3. Запуск локального сервера

Після встановлення всіх залежностей можна запустити локальний сервер для розробки:

```bash
npm run dev
```

або

```bash
yarn dev
```

Локальний сервер буде доступний за адресою [http://localhost:3000](http://localhost:3000).

### 4. Встановлення додаткових бібліотек

Для інтеграції інших бібліотек скористайтесь наступними командами. Наприклад, для встановлення axios для роботи з HTTP-запитами:

```bash
npm install axios
```

або

```bash
yarn add axios
```

## Компоненто-орієнтований підхід

Проект побудований на основі компоненто-орієнтованого підходу, який дозволяє розділяти код на незалежні, повторно використовувані частини. Кожен компонент відповідає за певну функціональність, що спрощує підтримку та масштабування проекту.

### Переваги компонентного підходу:

1. **Повторне використання коду**: Компоненти можуть використовуватися в різних частинах додатку.
2. **Легка підтримка**: Зміни в одному компоненті не впливають на інші.
3. **Простота тестування**: Кожен компонент можна тестувати окремо.

## Структура проекту

Структура проекту відповідно до загальний практик та кращої довгострокової підтримки. Директорія app є точкою входу у контекті роутингу 
(Next App Router (роутинг, який визначається структурою директорій та файлами page.jsx)).

```plaintext
react-next-lesson/
│
├── .next/                        # Директорія для згенерованих файлів Next.js (білд, кеш, тощо)
├── api/                          # API-роути, логіка звернення до сервера
│   └── user/                    
│       └── index.js              
├── app/                          # Директорія App Router
│   ├── login/                    # Сторінка авторизації
│   │   └── page.jsx              # Компонент сторінки логіну
│   ├── profile/                  # Сторінка профілю
│   │   ├── page.jsx              # Компонент сторінки профілю (/profile/)
│   │   ├── [id]/                 # Динамічний маршрут для профілю користувача за id
│   │   │   └── page.jsx          # Компонент сторінки для профілю користувача за id (/profile/1020/)
│   ├── axios/                    # Налаштування Axios для запитів
│   │   └── index.js             
│   ├── favicon.ico               # Іконка сайту
│   ├── globals.css               # Глобальні стилі
│   ├── layout.jsx                # Основний макет сторінок
│   └── page.jsx                  # Головна сторінка (/)
├── components/                   # Компоненти інтерфейсу
│   ├── layout/                   # Компоненти, що використовуються в макеті
│   │   ├── header/               # Шапка сайту
│   │   │   └── Navbar.jsx        # Навігаційний бар
│   ├── login/                    # Компоненти, що стосуються авторизації
│   │   └── LoginForm.jsx         # Форма для логіну
│   └── profile/                  # Компоненти профілю користувача
│       └── ProfileCard.jsx       # Карточка профілю
├── context/                      # Контексти для глобального стану
│   └── AuthContext.js            # Контекст авторизації
├── public/                       # Статичні файли, такі як зображення, шрифти тощо
├── services/                     # Сервіси для реалізації модульної логіки (авторизація, валідація, кастомні функції що обробляють інформацію перед запитом чи безпосередньо його результат)
│   └── auth/                     
│       └── index.js              
├── .gitignore                    # Файл для ігнорування файлів у Git
├── jsconfig.json                 # Конфігурація JavaScript для Next.js
├── next.config.mjs               # Конфігурація для Next.js
├── package.json                  # Залежності проекту та скрипти
├── postcss.config.mjs            # Конфігурація PostCSS
├── tailwind.config.js            # Конфігурація Tailwind CSS
└── README.md                     # Файл документації (цей файл)

```

### Компоненти

- **layout.js**: Відповідає за загальний макет сторінок (header, footer тощо).
- **page.js**: Основна сторінка додатку, яка використовує компоненти для відображення вмісту.

Ця структура дозволяє легко масштабувати проект та додавати нові сторінки й компоненти, зберігаючи порядок і логіку в організації коду.

### Імпорт/Експорт функцій, компонентів.

Для експортування функцій бізнес логіки гарною практикою є створення глобального index.js файлу для модуля, імпортувати в нього всі сабмодулі та імпортувати конкретні функції з цього index.js

```js
export {fetchUserProfile, loginUser} from './user'  # /api/user/index.js

// ---

import {fetchUserProfile} from '@/api' # приклад імпортування
```

Компоненти краще експортувати як цілий файл, це дозволяє притримувати принципу "самостійних компонентів" та зберігати розуміння, що кожен jsx файл це окремий компонент

```jsx
export default function LoginForm() {
    return <div></div>
}

// ---

const LoginForm = () => {
    return <div></div>
}

export default LoginForm


// ---

import LoginForm from "@/components/login/LoginForm";

```

### Axios

Для чистоти коду та покращення підтримки додатку гарною практикою є налаштування axios інстанса та в подальшому використання його для всіх запитів.
Це дозволяє уникнути повторення домену в url.

```js

import axios from 'axios';

const api = axios.create({
    baseURL: 'https://api.example.com',
});

export default api;

// ---

import api from "@/axios";

export const fetchUserProfile = (token) =>
    api.get('/profile', {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    });

```

### Використання пропсів та динамічних параметрів у Next.js

#### Що таке пропси в React?

Пропси (props) — це спосіб передавання даних від одного компонента до іншого. Вони дозволяють зробити компоненти більш гнучкими та повторно використовуваними, оскільки компоненти можуть отримувати різні значення через пропси залежно від контексту їх використання.

Пропси в Next.js можуть передаватися не тільки між компонентами, а й використовуватися для отримання даних у динамічних маршрутах.

#### Приклад використання пропсів у компоненті:

```jsx
const ProfileCard = ({ user }) => {
    return (
        <div>
            <h2>{user.name}</h2>
            <p>Email: {user.email}</p>
        </div>
    );
};

// Використання компонента з пропсами
const UserProfile = () => {
    const user = {
        name: "John Doe",
        email: "john.doe@example.com"
    };

    return <ProfileCard user={user} />;
};
```

У цьому прикладі `ProfileCard` приймає об'єкт `user` як пропс і використовує його для відображення даних користувача.

#### Динамічні сторінки та отримання параметрів

Next.js надає потужний механізм для створення динамічних сторінок. Для цього використовуються динамічні сегменти маршруту, які визначаються за допомогою квадратних дужок, наприклад, `[id].js`.

#### Приклад динамічної сторінки:

1. **Створення динамічного маршруту:** Якщо ви хочете створити сторінку профілю для кожного користувача за його `id`, потрібно створити файл з назвою `[id].js` або `[id].jsx`.

2. **Отримання `id` з динамічного маршруту:**

Next.js надає спеціальну функцію `useRouter` для доступу до параметрів маршруту. З її допомогою можна отримати значення параметра `id` та використовувати його для отримання даних про користувача або інших ресурсів.

```jsx
'use client';

import { useRouter } from 'next/navigation';

const UserProfile = () => {
    const router = useRouter();
    const { id } = router.query; // Отримуємо динамічний параметр id

    // Приклад використання id для отримання даних
    return (
        <div>
            <h1>Профіль користувача з ID: {id}</h1>
        </div>
    );
};

export default UserProfile;
```

У цьому прикладі:

- **Файл `[id].jsx`** визначає динамічну сторінку профілю користувача, де `id` є параметром URL.
- Використовується хук `useRouter`, щоб дістати параметр `id` з URL і відобразити його на сторінці.

#### Передавання пропсів у динамічні сторінки

У Next.js динамічні сторінки можуть також використовувати серверні функції для отримання даних ще до рендерингу сторінки на клієнті. Наприклад, за допомогою `getServerSideProps` ви можете отримати дані на основі `id` і передати їх у компонент як пропси.

```jsx
export async function getServerSideProps(context) {
    const { id } = context.params;
    const user = await fetchUserById(id); // Запит на сервер для отримання користувача

    return {
        props: {
            user, // Передаємо дані користувача у пропси
        },
    };
}

const UserProfile = ({ user }) => {
    return (
        <div>
            <h1>{user.name}</h1>
            <p>Email: {user.email}</p>
        </div>
    );
};

export default UserProfile;
```

У цьому прикладі `getServerSideProps` отримує `id` з параметрів маршруту, запитує дані користувача і передає їх як пропси до компонента.

#### Висновок:

- **Пропси** дозволяють компоненти бути більш гнучкими та багаторазово використовуваними.
- **Динамічні маршрути** дозволяють створювати сторінки з параметрами в URL (наприклад, профілі за ідентифікатором).
- За допомогою `useRouter` або серверних функцій Next.js можна отримувати параметри динамічного маршруту і використовувати їх для отримання даних або інших логічних операцій.

### Використання та контексту в Next.js

#### Що таке контекст?

Контекст в React дозволяє передавати дані через дерево компонентів без необхідності пропсів на кожному рівні. Це особливо корисно для управління станом, який має бути доступним у різних частинах вашого додатку, наприклад, для теми, мови інтерфейсу або авторизації.

#### Чому потрібен контекст для авторизації?

Авторизація є ключовим аспектом багатьох додатків. Під час авторизації ми маємо справу з токенами доступу, які дозволяють ідентифікувати користувача та надавати доступ до захищених ресурсів. Оскільки доступ до інформації про авторизацію може знадобитися у багатьох компонентах (наприклад, для відображення профілю користувача, керування маршрутизацією або обмеження доступу до певних сторінок), зручніше використовувати контекст.

#### Як працює контекст авторизації?

У цьому прикладі, контекст авторизації (`AuthContext`) забезпечує:

1. **Збереження стану авторизації:** Токен авторизації (`authToken`) та інформація про користувача (`user`) зберігаються у стані та є доступними через контекст.

2. **Обробка логіну та логауту:** Функції `login` та `logout` управляють процесами авторизації, зберігають/видаляють токен та оновлюють стан користувача.

3. **Захист маршрутів:** При спробі доступу до захищених сторінок без токену, користувач буде перенаправлений на сторінку логіну.

4. **Глобальна доступність:** Усі компоненти, які є дочірніми до `AuthProvider`, можуть отримувати доступ до контексту за допомогою хука `useAuth`.

#### Приклад інтеграції:

- Компонент `AuthProvider` обгортає усі компоненти, які потребують доступу до стану авторизації.

- Використовуючи `useAuth`, будь-який компонент може отримати інформацію про поточного користувача або викликати функції логіну чи логауту.

Це дозволяє централізовано керувати авторизацією у вашому додатку та забезпечити зручний доступ до необхідних даних та методів у будь-якому компоненті.

### Використання хуків у контексті автентифікації

React Hooks надають можливість використовувати стан (`state`) та інші функціональні можливості React без написання класів. У прикладі `AuthProvider` використовуються такі основні хуки:

- `useState`: Для зберігання стану `authToken`, `user` та `loading`.
- `useEffect`: Для виконання побічних ефектів, таких як перевірка наявності токену при завантаженні компонента.
- `useContext`: Для отримання доступу до контексту автентифікації у будь-якому компоненті.

#### Основні приклади

**useState:**

```javascript
const [authToken, setAuthToken] = useState(null);
```

`useState` ініціалізує стан та повертає його значення разом з функцією для його оновлення.

**useEffect:**

```javascript
useEffect(() => {
    // Логіка перевірки токену
}, []);
```

`useEffect` викликається після того, як компонент був вмонтований або оновлений. У прикладі він використовується для перевірки токену під час завантаження.

**useContext:**

```javascript
export const useAuth = () => useContext(AuthContext);
```

`useContext` дозволяє отримати доступ до контексту автентифікації у будь-якому дочірньому компоненті `AuthProvider`.

Ці хуки допомагають реалізувати автентифікацію на фронтенді та забезпечують доступ до стану користувача та функцій логіну/логауту у всьому додатку.

### Принцип роботи з JWT на фронтенді

JWT (JSON Web Token) — це стандарт, що використовується для передачі даних між двома сторонами у вигляді об'єкта JSON, який може бути верифікований завдяки цифровому підпису. На фронтенді JWT зазвичай використовуються для збереження токенів автентифікації, які дозволяють користувачам залишатися залогіненими протягом певного часу.

#### Основні кроки роботи з JWT на фронтенді

1. **Збереження токена**: Після успішної автентифікації користувача сервер повертає JWT токен. Цей токен необхідно зберегти на фронтенді (наприклад, у `localStorage` або `sessionStorage`).

2. **Використання токена для запитів**: Коли користувач робить запити до серверу, токен додається до заголовка запиту для верифікації автентифікації.

3. **Декодування токена**: Токен може містити корисну інформацію (наприклад, ім'я користувача, роль тощо). Ви можете декодувати токен, щоб витягнути ці дані.

4. **Видалення токена**: При виході користувача з системи необхідно видалити токен, щоб запобігти несанкціонованому доступу.


#### Приклад коду роботи з JWT:

Розглянемо код, який ви надали, для роботи з JWT на фронтенді:

```javascript
import jwtDecode from 'jwt-decode';

// Зберігає токен у localStorage
export const setToken = (token) => {
    localStorage.setItem('token', token);
};

// Отримує токен з localStorage
export const getToken = () => {
    return localStorage.getItem('token');
};

// Декодує токен, щоб витягнути з нього інформацію
export const decodeToken = (token) => {
    try {
        return jwtDecode(token);
    } catch (e) {
        return null;
    }
};

// Видаляє токен з localStorage
export const removeToken = () => {
    localStorage.removeItem('token');
};
```

#### Детальніше про принципи роботи:

1. **Збереження токена**:
    - Функція `setToken(token)` зберігає JWT токен у `localStorage` під ключем `'token'`. Це робиться для того, щоб мати доступ до токену між різними сесіями браузера.

   ```javascript
   setToken('your_jwt_token');
   ```

2. **Отримання токена**:
    - Функція `getToken()` повертає токен з `localStorage`. Це корисно для додавання токена до заголовків запитів або перевірки, чи користувач залогінений.

   ```javascript
   const token = getToken();
   ```

3. **Декодування токена**:
    - Функція `decodeToken(token)` використовує бібліотеку `jwt-decode`, щоб витягнути інформацію з токена. Ця інформація може містити дані про користувача, термін дії токена, тощо.

   ```javascript
   const decoded = decodeToken(token);
   console.log(decoded); // { userId: '123', exp: 1609459200, ... }
   ```

4. **Видалення токена**:
    - Функція `removeToken()` видаляє токен з `localStorage`, що корисно при виході користувача з системи.

   ```javascript
   removeToken();
   ```

#### Приклад використання JWT у запитах:

Після того, як токен збережений, він може бути використаний для авторизації запитів до захищених ресурсів на сервері:

```javascript
const token = getToken();

fetch('/api/protected-resource', {
    method: 'GET',
    headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
    }
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));
```